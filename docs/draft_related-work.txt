2. Related Work
A. Broker-Level Priority Mechanisms
Beberapa penelitian mencoba menambahkan mekanisme prioritas pada MQTT broker. Kim et al. (2018) mengusulkan p-MQTT dengan 3 priority queue di broker: Urgent, Critical, dan Normal. Message type field digunakan untuk klasifikasi, tapi hanya bisa 3-4 level prioritas. Kim (2017) menggunakan 2-bit priority field di MQTT header yang memberi 4 priority level. Tachibana et al. (2016) membuat priority control mechanism berbasis polling dimana broker mengatur kapan publisher boleh transmit.
Akshatha et al. (2024) mengusulkan pendekatan serupa menggunakan RabbitMQ sebagai broker dengan dukungan AMQP. Sistem ini mengklasifikasikan pesan ke dalam tiga virtual queue: Urgent, Critical, dan First Come First Served (FCFS). Pesan disimpan ke database MySQL untuk analisis lebih lanjut. Hasil eksperimen menunjukkan bahwa queue Urgent dan Critical memiliki end-to-end delay dan jitter yang lebih rendah dibandingkan pendekatan FCFS konvensional. Kelebihan pendekatan ini adalah tidak memerlukan modifikasi protokol MQTT standar.
Masalah pendekatan broker-level ini adalah hanya bekerja di application layer. Jaringan antara publisher dan broker tidak mengetahui mana pesan prioritas tinggi. Jadi kalau terjadi congestion di network, pesan urgent tetap bisa mengalami delay karena switch memperlakukan semua traffic sama. Proteksi priority hanya ada di broker, tidak di infrastruktur jaringan.
B. Protocol Modification Approaches
PrioMQTT yang dikembangkan oleh Patti et al. (2024) merupakan pendekatan yang memodifikasi protokol MQTT dengan mengganti transport layer dari TCP menjadi UDP. Nilai prioritas sebesar 64-bit disisipkan ke dalam User Properties pada MQTT v5.0, dan broker diperluas dengan priority transmission queue. Pendekatan ini menghasilkan peningkatan performa yang signifikan, dengan pengurangan round-trip time (RTT) antara 51.30% hingga 79.14% dibandingkan MQTT standar. Selain itu, implementasinya relatif sederhana karena hanya memerlukan modifikasi pada broker tanpa membutuhkan dukungan perangkat jaringan khusus.
Namun, pendekatan ini memiliki beberapa trade-off penting. Pertama, penggunaan UDP membuatnya tidak backward compatible dengan protokol MQTT standar yang berbasis TCP. Aplikasi yang sebelumnya mengandalkan reliabilitas bawaan TCP perlu menangani retransmisi secara manual. Kedua, mekanisme prioritas pada PrioMQTT hanya bekerja pada level aplikasi; infrastruktur jaringan tetap tidak mengetahui perbedaan tingkat urgensi pesan. Akibatnya, jika jaringan mengalami flooding oleh trafik non-MQTT, PrioMQTT tidak mampu memberikan perlindungan QoS, karena switch tidak dapat membedakan trafik prioritas tinggi dari trafik lain pada layer jaringan.
Testa et al. (2024) mengusulkan integrasi PrioMQTT dengan Time-Sensitive Networking (TSN) untuk mengatasi keterbatasan ini. Prioritas pesan dipetakan ke SR class A dan B pada IEEE 802.1Q dengan Credit-Based Shaper untuk bounded delay. Namun, pendekatan ini memerlukan infrastruktur TSN yang belum tersedia secara luas.
C. SDN-Based MQTT Integration
RT-MQTT yang dikembangkan oleh Shahri et al. (2022) merupakan pendekatan yang paling komprehensif dalam mengintegrasikan MQTT dengan Software-Defined Networking. Sistem ini memperkenalkan arsitektur Real-Time Network Manager (RT-NM) yang bertindak sebagai middleware antara MQTT broker dan SDN controller. RT-NM melakukan inspeksi mendalam terhadap pesan MQTT dengan membaca topic dan payload untuk menentukan tingkat prioritas, kemudian secara dinamis menginstal flow rules yang spesifik untuk setiap topik MQTT ke dalam switch OpenFlow. Pendekatan ini memberikan kontrol end-to-end yang granular, dimana setiap topik MQTT dapat memiliki path dan priority yang berbeda di jaringan.
Meskipun RT-MQTT menunjukkan hasil yang menjanjikan dalam hal pengurangan latency untuk traffic prioritas tinggi, arsitektur ini memiliki beberapa kelemahan. Pertama, kompleksitas implementasi sangat tinggi karena memerlukan komponen middleware tambahan yang harus melakukan deep packet inspection pada setiap pesan MQTT. Hal ini menimbulkan overhead pemrosesan dan dapat menjadi bottleneck ketika jumlah pesan meningkat. Kedua, instalasi flow rules per-topik MQTT dapat menyebabkan ledakan jumlah flow rules pada switch, terutama dalam sistem IoT skala besar dengan ratusan atau ribuan topik yang berbeda. Ketiga, pendekatan ini memerlukan akses ke broker untuk membaca isi pesan, yang menambah coupling antara komponen jaringan dan aplikasi. Sebagai perbandingan, pendekatan berbasis DSCP dapat menghindari kompleksitas ini dengan melakukan marking pada sisi publisher dan memproses prioritas langsung di data plane tanpa memerlukan packet inspection atau flow rules per-topik. 

D. DSCP-Based SDN Approaches
Differentiated Services Code Point (DSCP), sebagaimana didefinisikan dalam RFC 2474, telah lama digunakan dalam jaringan tradisional untuk memberikan mekanisme Quality of Service (QoS) pada berbagai jenis trafik, seperti VoIP, video streaming, dan enterprise communication. DSCP merupakan field 6-bit pada byte Type of Service (ToS) pada header IP yang diproses langsung oleh perangkat jaringan (switch/router) di level hardware, sehingga tidak membutuhkan intervensi controller dan memiliki latency sangat rendah. Nilai-nilai DSCP standar umumnya mencakup EF (46) untuk trafik sangat kritis, AF4x (34) untuk prioritas tinggi, AF3x (26) untuk prioritas menengah, AF1x (10) untuk prioritas rendah, dan BE (0) untuk best-effort traffic.
Penelitian terbaru oleh Yaseen et al. (2024) memanfaatkan modifikasi DSCP pada jaringan SDN untuk meningkatkan traffic flow continuity control. Dalam pendekatan ini, controller SDN secara dinamis mengubah DSCP bits ketika terjadi perubahan flow rule pada runtime, dengan tujuan mencegah gangguan aliran data selama proses path switching. Hasil eksperimen menunjukkan peningkatan hingga 65% dalam kontinuitas aliran serta pengurangan signifikan pada queuing delay. Evaluasi dilakukan menggunakan trafik generik seperti voice, video, dan text dalam lingkungan Mininet.
Meskipun demikian, penelitian tersebut berfokus pada flow continuity dan fast rerouting untuk trafik generik, bukan pada application-level prioritization dalam konteks IoT. Modifikasi DSCP dilakukan secara tersentralisasi oleh controller, bukan pada sisi aplikasi. Lebih jauh lagi, penelitian tersebut tidak menghubungkan DSCP dengan semantik pesan tertentu, dan tidak membahas protokol IoT seperti MQTT. Dengan demikian, meskipun DSCP telah banyak digunakan untuk QoS pada jaringan tradisional dan SDN, hingga saat ini belum ada penelitian yang mengimplementasikan DSCP sebagai mekanisme prioritas yang dipicu oleh semantik aplikasi (misalnya anomaly vs normal data) pada protokol MQTT. Ini membuka ruang penelitian baru untuk pemetaan application semantics ke network-layer QoS dalam sistem IoT berbasis MQTT.
E. Research Gap
Gap utama dari penelitian sebelumnya adalah tidak adanya mekanisme yang menggabungkan DSCP marking berbasis semantik aplikasi dengan SDN untuk protokol MQTT. Penelitian ini mengusulkan kerangka kerja hybrid dimana DSCP marking dilakukan di application layer (publisher) berdasarkan semantik data (anomaly vs normal), sementara prioritization dilakukan di network layer (SDN) menggunakan flow rules per-DSCP yang scalable. Pendekatan ini backward compatible dengan MQTT standar, memberikan proteksi QoS end-to-end, dan tidak memerlukan deep packet inspection atau flow rules per-topik.
